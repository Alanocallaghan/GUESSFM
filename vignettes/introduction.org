#+TITLE: GUESSFM: using GUESS for Fine Mapping
#+AUTHOR: Chris Wallace
#+EMAIL: chris.wallace@cimr.cam.ac.uk
#+DATE: 2013-12-03 Tue
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE: en
#+OPTIONS: H:3 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS: TeX:t LaTeX:t skip:nil d:(not LOGBOOK) todo:t pri:nil tags:t

#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:
#+LINK_HOME:
#+XSLT:

#+latex_header: \usepackage{fullpage}
#+latex: %\VignetteIndexEntry{GUESSFM Introduction}

#+begin_html
<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{GUESSFM Introduction}
-->
#+end_html

* Introduction

[[http://www.bgx.org.uk/software/guess.html][GUESS]] is software for Bayesian variable selection and model averaging
using a stochastic search algorithm to visit the most likely models
via MCMC.  There also exists an R package, [[http://cran.r-project.org/web/packages/R2GUESS/index.html][R2GUESS]], which is a wrapper
for running GUESS, and provides useful diagnostic and summary
functions.

This package, GUESSFM, aims to extend GUESS for fine mapping, defined
here as the task of identifying the most likely set of causal
variants.  The are particular challenges for fine mapping, mostly
related to the density of SNP markers.  Nonetheless, this vignette
will at first focus on an example dataset that comes with R2GUESS.

* R2GUESS Strategy 

Although GUESS uses g-priors, which inhibits visiting models with SNPs
in high LD, we have found that running GUESS with SNPs in complete LD
can lead to instability.  R2GUESS was created purely to allow running
GUESS on a tagged set of SNPs to approximate the posterior model
space, and then expand the most interesting models to include their
tags.  It is perhaps useful to give an example of expanding a model.

Suppose we begin tagging, and determine a couple of /tag groups/ as follows:

| Tag | SNPs in tag group |
| $A$ | $A_1$, $A_2$      |
| $B$ | $B_1$             | 

R2GUESS will remove SNPs A1, A2 and B1, and will save a file
containing an object of class =tags= containting the information in
the above table.  Then, suppose after GUESS has run on the set of tag
SNPs, model $(A,B)$ is one of the most interesting.  GUESS FM will
`expand' this model to the set of models ${(A,B), (A_1,B), (A_2,B),
(A,B_1), (A_1,B_1), (A_2,B_1)}$.  

We assess each model using Bayes Factors.  The Bayes Factor for model
$M_i$ is 

$$BF_{i0} = \frac{P(M_i | \text{data} )}{P(M_0 | \text{data})}.$$

In a fully Bayesian analysis, the individual model
probabilities are calculated by integrating over prior distributions
for the model parameters (regression coefficients, for example).  This
is what GUESS does.  However, it assumes a linear model when often we
will want to fine map a disease trait and therefore use a logistic
model.  Further, we cannot go back and run the expanded models through
GUESS.  Instead, we use Approximate Bayes Factors, based on the BIC:

$$-2 \log{ABF_{i0}} = BIC(M_i) - BIC(M_0).$$

These are calculated within R via the =glm= and =BIC= functions.  

At what threshold should you tag?  Probably, as high as you can go
without inducing instability in GUESS.  We have found $r^2=0.99$ to
work in some large datasets, but your mileage may vary.  In the
examples below we use a lower threshold purely for demonstration.

* Simulate some data

We start with using some sample data from the snpStats package
including 20 SNPs, and simulating a quantitative trait that depends
on 3 causal SNPs.

#+begin_src R :ravel :label=sim
library(snpStats)
data(for.exercise, package="snpStats")
set.seed(12346)
X <- snps.10[,101:120]
n <- nrow(X)
causal <- c("rs1555897","rs7069505")
Y <- rnorm(n,mean=as.numeric(X[,causal[1]]))*sqrt(0.2) +
  rnorm(n,mean=as.numeric(X[,causal[2]]))*sqrt(0.2) +
  rnorm(n)*sqrt(0.6)
#+end_src

=X= contains some missing genotypes, but no SNPs with such a low call
rate we would worry in a large study. Still, the rest of the analysis
is easier to interpret for the purposes of a vignette if we fill in
the missing values.

#+BEGIN_SRC R :label=descsim
library(GUESSFM)
summary(col.summary(X))
X <- impute.missing(X)
summary(col.summary(X))
#+END_SRC

Looking at the LD, we see this is a region in which D' (above the
diagonal) is typically high, whilst $r^2$ can be high between some SNPs,
and with moderately strong $r^2 \simeq 0.7$ between two of our causal
SNPs:
#+begin_src R :ravel :fig=TRUE :label=ldfig
ld <- show.ld(X=X)
#+end_src


* Running GUESS and reading output

First, via GUESSFM's wrapper, tagging at $r^2=0.8$.  This is
considerably lower than suggested above, and is used here purely for
demonstration as there is limited strong LD in this dataset.

: ## THIS DIRECTORY WILL HOLD ALL THE GUESS INPUT AND OUTPUT 
: ## AND WILL BE CREATED IF IT DOESN'T ALREADY EXIST
: mydir <- tempfile() 
: ## NB, IF GUESS IS NOT ON YOUR PATH, SUPPLY THE FULL PATH IN AN ARGUMENT
: ## guess.command="/path/to/GUESS"
: run.bvs(X,Y,gdir=mydir,backend="guess",tag.r2=0.8,guess.command="/home/chrisw/GUESS_v1.1/Main/GUESS") 


#+BEGIN_SRC 
## THIS CAN TAKE A WHILE.  FOR THE PURPOSES OF THIS VIGNETTE, 
## WE WILL LOAD THE RESULTS FROM AN EXISTING RUN.
mydir <-  system.file("inst","extdata",package="GUESSFM")

## what files were created?
list.files(mydir)

## read output with GUESSFM
d <- read.snpmod(mydir)

## examine the best models and SNPs with greatest marginal support within the tagged data.
best.models(d)
best.snps(d)
#+END_SRC


Note that both =best.models= and =best.snps= allow you to specify thresholds for
how to determine "best".  See their help pages for details.

The tags created within the =run.bvs= function are saved to a
=tags.RData= file under =mydir= and can be examined.

#+BEGIN_SRC R
(load(file.path(mydir,"tags.RData")))
tags

#+END_SRC

**** TODO Which SNPs were selected as tags, esp in relation to causal variants?  Which SNPs come up in the GUESS results?

* TODO run via R2GUESS and read output


You can convert a run from R2GUESS into a snpmod object with:

#+BEGIN_SRC 
## read output using a convenience wrapper for as.ESS.object()
## this returns an object of class ESS, used by R2GUESS
ess <- read.ess(mydir)
str(ess)

## GUESSFM maps snp numbers to names via a decode vector
decode <- structure(colnames(X),names=as.numeric(1:length(X)))

## create a snpmod
gfm2 <- ess2snpmod(ess)
best.models(gfm2)
#+END_SRC

* Expanding

#+BEGIN_SRC R
dx<-expand.tags(d,tags)

#+END_SRC
* Plotting
It is useful to assess the steps of any analysis by looking at the data.  With such
a large number of models, the best way to look is to plot.  For that
reason, GUESSFM contains lots of plotting functions.

?? separate vignette, including vagaries of ggplot?


* Parallelism

Looping over many, many models can be made quicker by parallel
processing.  GUESSFM does this by means of calls to the =mclapply=
function in the =parallel= package.  By default, 
the =parallel= package sets itself up to use two cores.  You can
change this by setting the option =mc.cores=.  Eg, if you have 20
cores on your machine, you might set
: options(mc.cores=16)
to use 16 of this for R, and leave the remainder free to run other
processes.

Functions which make use of this (and over which you might then not to
use =mclapply= are: 

=expand.tags=


